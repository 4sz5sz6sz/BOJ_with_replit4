# E번 - 초콜릿 괴도 코코 (Sweet)
시간 제한	메모리 제한
2 초	1024 MB
### 문제
추리 소설 “초콜릿 괴도 레나”를 감명 깊게 읽은 코코는 이 소설의 명장면을 따라 해 보기로 했다. 구체적인 방법은 다음과 같다.

1단계 : 먼저 $N\times N$ 크기의 사각 격자 형태의 초콜릿을 준비한다. 이 초콜릿은 $1\times 1$ 단위로 원하는 곳에서 떼어낼 수 있게 되어 있으며, $0$개 이상의 단위 초콜릿이 제거된 상태이다. 이때, 남아있는 단위 초콜릿은 $4$개 이상이며, 한 조각을 이루어야 한다. 상하좌우로 이웃한 두 단위 초콜릿은 서로 연결되어 있으며, 서로 연결된 단위 초콜릿들의 집합을 하나의 조각이라고 한다.
2단계 : 이 초콜릿에서 다음의 조건을 충족하도록 하나의 단위 초콜릿을 떼어 먹는다.
이 단위 초콜릿을 떼어낸 후에도 남아있는 초콜릿은 하나의 조각을 이루지만, 그 이후에 이웃이 $2$개 이상인 단위 초콜릿을 아무거나 떼어내면 $2$개 이상의 조각으로 나누어진다.
3단계 : 레나의 명대사를 외친다. “이번엔 봐줬지만, 다음에는 반드시 초콜릿을 조각내 줄 거야.”
코코는 1단계의 조건을 충족하는 초콜릿을 준비해 놓았지만, 2단계의 조건을 충족하려면 어느 지점에 있는 단위 초콜릿을 떼어내야 할지 고민에 빠졌다. 코코를 도와주자.

### 입력
첫 번째 줄에는 초콜릿의 크기 $N$이 주어진다. $(2\le N\le 40)$ 

두 번째 줄부터 $N$줄에 걸쳐서 초콜릿의 상태가 주어진다. 각 줄에는 각 칸에 단위 초콜릿이 있는지를 나타내는 문자 $N$개가 공백 없이 주어진다. 각 문자는 모두 # 또는 .이며, 초콜릿의 $r$번째 줄의 $c$번째 글자가 #이면 $r$행 $c$열에 단위 초콜릿이 있음을, .이면 없음을 뜻한다. 초콜릿의 맨 왼쪽 위 칸은 $1$행 $1$열이다.

모든 입력은 1단계의 조건을 충족한다.

### 출력
첫 번째 줄에는 2단계의 조건을 충족하도록 떼어낼 수 있는 서로 다른 단위 초콜릿의 개수를 출력한다.

다음 줄부터는 그러한 단위 초콜릿의 행 번호와 열 번호를 한 줄에 하나씩 출력한다. 이때, 행 번호가 작은 것부터, 행 번호가 같은 것들 중에서는 열 번호가 작은 것부터 출력한다.


### 예제 입력 1 
```
3
###
#.#
###
```
### 예제 출력 1 
```
8
1 1
1 2
1 3
2 1
2 3
3 1
3 2
3 3
```
### 예제 입력 2 
```
3
##.
###
###
```
### 예제 출력 2 
```
1
2 2
```
### 풀이
- Brute Force
- BFS
	- flood fill



#칸 하나를 선택하여 떼어 낸다..
	나머지 #만으로 한조각을 이루는지 flood fill 검사.
		만약, 한 조각을 이룬다면
			남아있는 # 조각 중 하나를 선택한다.
			두 조각을 이루는지 flood fill 검사.
				~~두 조각을 이룬다면, ans에 현재 #칸 좌표 추가.~~
		그렇지 않다면
			break;

char board[IDX_MAX][IDX_MAX];
//bool exc[IDX_MAX][IDX_MAX];	//예외 조각 최대 2곳.
Pos exc1, exc2;	//예외 조각 최대 2곳

int numOfCho;	//초콜릿 갯수.
vector<Pos> st;	//시작점 3개 저장해두기. 예비 1번~3번;

bool isOnePiece(Pos start);
bool oob(int nx, int ny, int x, int y);
bool func1(Pos start);	//1번째 조각 떼어내기
//bool func2(Pos start);	//2번째 조각 떼어내기

bool func1(Pos start){
	exc1 = start; exc2 = {-1,-1};
	Pos st;	//아무 조각 선택. 2중 for문 돌리기.
	if(isOnePiece(st2)){	//첫번째 조각 떼어내기
		for() x
			for() y //남아있는 조각 하나 선택, 전수 검사.
				exc2에 현재 조각 저장.
				st = ();	//아무 조각 선택. 2중 for문 돌리기.
				두 조각을 이루는지 flood 검사.	//두번째 조각 떼어내기.
					두 조각이 맞다면, 
						검사 속행,
					한 조각이라면,
						return false;
	}
	return true;
}

bool isOnePiece(Pos start){
	int cnt=0;
	BFS 수행;
	//(단, exc1과 exc2를 고려한다.)
	
	한 조각을 이룬다면
		return true;
	그렇지 않다면
		return false;
}

차라리 함수 3개로 나누는게 나을 듯..

23:05 잠시 멈춤..