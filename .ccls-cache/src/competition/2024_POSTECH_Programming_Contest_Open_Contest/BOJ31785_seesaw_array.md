K번 - 시소 배열
시간 제한	메모리 제한
1 초	1024 MB
문제
비어 있는 배열 $A$가 있다. 당신은 다음 두 종류의 질의를 총 $Q$개 처리해야 한다.

1 x : 배열의 가장 뒤에 정수 $x$를 삽입한다.
2 : 현재 배열의 길이를 $N$이라 하자. 배열을 앞 

$\lfloor{N\over 2}\rfloor$개의 원소와 뒤 

$\lceil{N\over 2}\rceil$개의 원소 두 부분으로 나눈 후, 원소들의 합이 더 작은 부분을 배열에서 삭제한다. 만약 두 부분의 합이 같을 경우, 앞 

$\lfloor{N\over 2}\rfloor$개의 원소를 삭제한다. 이후 삭제된 부분의 원소의 합을 출력한다. 이 형식의 질의는 배열의 길이가 $2$ 이상일 때만 주어진다.
모든 질의를 올바르게 처리하고, 그 후 배열 $A$에 저장된 모든 원소를 차례대로 출력하는 프로그램을 작성하여라.

입력
첫 번째 줄에 질의의 수 $Q$가 주어진다. $(3\le Q\le 500\ 000)$ 

두 번째 줄부터 $Q$개의 줄에 걸쳐 질의가 아래와 같은 형식 중 하나로 주어진다.

1 x : $(1\le x\le 1\,000)$, $x$는 정수
2
2번 질의가 1번 이상 주어지며, 모든 2번 질의는 배열의 길이가 $2$ 이상일 때 주어짐이 보장된다.

출력
각 2번 질의에 대한 답을 차례대로 각 줄에 걸쳐 출력한다. 이후 다음 줄에 모든 질의를 처리한 후 배열 $A$에 저장된 모든 원소를 차례대로 출력한다.

예제 입력 1 
7
1 4
1 2
1 1
2
1 7
2
1 5
예제 출력 1 
3
4
7 5
노트
어떤 실수 $x$에 대해, $\lfloor{x}\rfloor$는 $n \le x$을 만족하는 가장 큰 정수 $n$의 값으로 정의된다. 마찬가지로, $\lceil{x}\rceil$은 $n \ge x$을 만족하는 가장 작은 정수 $n$의 값으로 정의된다.

### Solution

- 세그먼트 트리
	- 구간 합
point update
range query

명령어 '2'가 range update처럼 보이지만, 쿼리 범위에서 아예 배제시키면 되는 부분이기에,
range update를 구현할 필요가 없다.(?)

모든 쿼리에서, N의 최대 합은 500,000*4 이하인게 보장될 것이다(?)



int curN;


1 x
트리 제일 마지막 부분에 x를 삽입.
curN++

2
구간 합 쿼리,

앞의 합 vs 뒤의 합 비교.
적은 쪽 삭제.
int a = curN/2;
int b = curN - a
int mid;	//앞 범위의 가장 마지막 인덱스.
curN = a or b;
삭제된 합 출력.

이분탐색을 통해, a의 범위를 찾는다.

1부터, mid까지의 합이 curN/2 이 될 때까지 무한 반복.



#### 이분 탐색 구현
range update
point query
트리 하나 더 구현하기.
	- 노드의 존재 여부.
l~r 중, 존재하는 노드의 갯수 출력.

update_isused()
find_isused()
1 1 1 1 1
1 0 0 0 0

1 1 0 0 1 1 1 1
1 0 -1 0 1 0 0 0

//두번 삭제될 수도 있다. 그러면 1 -1 -2 -1 1이 될텐데, 0이하면 전부, 1번 이상 삭제된걸로 간주한다.

l을 -1로 update()
r+1을 1로 update()



#### 마지막 출력
update_isused(1)




####새로운 아이디어 33:27~48:02
update(int node, int l, int r, int idx, ll val),
find(int node, int l, int r, int st, int en) 에서
l과 r의 범위를 조정해버린다.
앞과 뒤만 잘라내는 것이지, 가운데를 삭제시키는 연산은 존재하지 않는다.
예를들어, 뒤만 잘라낸다면, 뒤에 있던 기존의 원소들은 아예 없는 취급을 해버리면 된다.
r을 절반으로 줄여버리면, 뒤에 있는 원소는 find의 리턴값(합계)에 포함되지 않는다.


1 x
트리 제일 마지막 부분에 x를 삽입.
curN++

2
구간 합 쿼리,

앞의 합 vs 뒤의 합 비교.
적은 쪽 삭제.

int mid = (st+en-1)/2;
1,2 1~1
mid = 1
1,2,3,4,5,6,7 1~3
mid = 3

쿼리 범위 
1~mid
mid+1~en

find[1~mid]
find[mid+1~en]
더 작은 쪽 삭제.
	l과 r값 조정.
	curN값 조정.
삭제된 합 출력

