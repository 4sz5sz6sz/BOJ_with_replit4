# 수열과 쿼리 16
시간 제한	메모리 제한	제출	정답	맞힌 사람	정답 비율
2 초	512 MB	6204	3111	2642	50.896%
### 문제
길이가 N인 수열 A1, A2, ..., AN이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.

1 i v : Ai를 v로 바꾼다. (1 ≤ i ≤ N, 1 ≤ v ≤ 109)
2 i j : Ai, Ai+1, ..., Aj에서 크기가 가장 작은 값의 인덱스를 출력한다. 그러한 값이 여러개인 경우에는 인덱스가 작은 것을 출력한다. (1 ≤ i ≤ j ≤ N, 1 ≤ v ≤ 109)
수열의 인덱스는 1부터 시작한다.
### 입력
첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 100,000)

둘째 줄에는 A1, A2, ..., AN이 주어진다. (1 ≤ Ai ≤ 109)

셋째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 100,000)

넷째 줄부터 M개의 줄에는 쿼리가 주어진다.

### 출력
2번 쿼리에 대해서 정답을 한 줄에 하나씩 순서대로 출력한다.


### 예제 입력 1 
```
5
5 4 3 2 1
6
2 1 3
2 1 4
1 5 3
2 3 5
1 4 3
2 3 5
```
### 예제 출력 1 
```
3
4
4
3
```

### 풀이
- 세그먼트 트리
	- Bottom-up
  - 수열과 쿼리

```
03:38 문제 분석
08:22 main() 작성 완료.
21:08 update() 작성 완료.
27:19 find() 작성 완료.
27:28 첫 컴파일
29:54 세그멘테이션 폴트
	-> if(l < st && en < r) return seg[node];
		에서
		if(l <= st && en <= r) return seg[node];
		로 수정.

	전부 0으로 출력되는 현상 발생..

41:51 오타 수정.
	int ret2 = update(node*21, mid+1, en, i, val);
	에서
	int ret2 = update(node*2+1, mid+1, en, i, val);
	로 수정.

01:00:38
	fill(arr,arr+IDX_MAX,INF);
	추가하니, 답에 더 근접해짐.

재개
10:56 값 추적 중.

29:35 ret1이 0으로만 리턴되는 현상 발생, 0이 아니라 seg[node]를 리턴해야 함.
if문 문장 순서 위치 2개 스왑시킴.

0 대신 seg[node]를 리턴시킴.

다시 if문 2개 스왑시킴. (출력 결과가 달라짐)

32:21 테스트 케이스 통과.

if문 순서에 따라 출력 결과의 변화를 보임.
update() 과정에서 함부로 0 return 하는 경우 없애기.

240304 01:00:38 + 34:15 이게 왜 맞지?
```



#### 반례 해석
(문장 1)
if(i < st || en < i) return seg[node];

(문장 2)
if(st==en){
	seg[node] = st;
	arr[st] = val;
	return st;	//첫 줄과 합칠 수 있음. 나중에 디버깅을 위해 분리함.
}

문장 1과 문장 2의 순서를 바꾸면 안되는 이유.

문장 2가 먼저 배치된다면, st== i 가 아님에도 불구하고, st==en라는 이유만으로
arr[st] = val; 
과 같은 arr[st]의 변동이 여러번 일어나게 된다.
arr[st]의 변동은 단 한 번만 일어나야 한다.
st==en이지만, i가 [st:en]을 벗어나는 경우가 상당히 많이 존재한다.