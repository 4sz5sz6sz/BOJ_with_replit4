#### 그리디로 풀기?
그때 그때마다, 가장 가까운 사람이 먼저 가기?

반례)
6
3
3 5
2 3
5 5

따라서, 그리디는 불가능.


#### dp로 풀기?
DP[i] : i번째 사건이 완료되었을 때의 이동 횟수, 두 차의 위치.
-> 항상 최솟값으로 유지하기에는, 탐색 횟수가 O(2^W)으로 예상된다...
그 순간마다의 최솟값만 따지기에는, '초반 멀리, 후반 가까이' 인 케이스가 염려된다. 역전의 기회가 존재한다.


int DP[i][0 or 1] : i번째 사건을 j가 수행하였을 때의 이동 횟수,
Pos POS[i][j] : i번째 사건을 j가 수행하였을 때의 두 차의 위치.



한번 시도해보기??


DP[i][j] = min(DP[i-1][0],DP[i-1][1])



#### N<=10일 때 브루트 포스로 한번 풀어보기? 검증 코드
